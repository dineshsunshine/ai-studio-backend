# Look History & Lookbook Implementation Guide

## 📋 Overview

### Current Problem
- Looks are only created when user saves to lookbook
- Token consumption happens at save time (late)
- No history of all generated looks
- Can't track looks that were generated but not saved

### Solution
Add a status flag to differentiate between:
- **All Looks** (History): Every look generated by AI
- **Lookbook** (Saved): Looks explicitly saved by user

### Key Changes
- ✅ Consume tokens immediately when look is generated
- ✅ Save look to database immediately (as draft)
- ✅ User can later "save to lookbook" with title/notes
- ✅ Filter to show only lookbook items or all items

---

## 🗄️ Backend Changes

### 1. Database Model Change

**File: `app/models/look.py`**

Add new field to `Look` model:

```python
class Look(Base):
    """
    Look represents a fashion look with products.
    Each look belongs to a user.
    """
    __tablename__ = "looks"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()), index=True)
    title = Column(String, nullable=True)
    notes = Column(Text, nullable=True)
    generated_image_url = Column(String, nullable=False)
    user_id = Column(String(36), ForeignKey("users.id"), nullable=True, index=True)
    
    # NEW FIELD
    is_in_lookbook = Column(Boolean, default=False, nullable=False, index=True)
    # Purpose: 
    # - False = Draft/History only (generated but not explicitly saved)
    # - True = Saved to lookbook (user explicitly saved it)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships (unchanged)
    products = relationship("Product", back_populates="look", cascade="all, delete-orphan")
    links = relationship("Link", secondary="link_looks", back_populates="looks")
```

---

### 2. Schema Updates

**File: `app/schemas/look.py`**

Add `is_in_lookbook` to response schema:

```python
class LookResponse(LookBase):
    """Schema for look in API responses"""
    id: str = Field(..., description="Unique identifier (UUID)")
    generated_image_url: str = Field(..., description="URL to the generated image")
    products: List[ProductResponse] = Field(..., description="List of products in this look")
    is_in_lookbook: bool = Field(..., description="Whether look is saved to lookbook")  # NEW
    created_at: str = Field(..., description="Creation timestamp")
    updated_at: str = Field(..., description="Last update timestamp")
    
    @field_serializer('id')
    def serialize_id(self, value: uuid.UUID, _info):
        return str(value)
    
    @field_serializer('created_at', 'updated_at')
    def serialize_datetime(self, value: datetime, _info):
        return value.isoformat()
```

---

### 3. New Endpoint: Save to Lookbook

**File: `app/api/v1/endpoints/looks.py`**

Add new endpoint to mark look as saved:

```python
@router.patch("/{look_id}/save-to-lookbook", response_model=LookResponse)
async def save_to_lookbook(
    look_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Mark a look as saved to lookbook.
    
    This is a lightweight operation that updates the is_in_lookbook status.
    The look must belong to the current user.
    
    **Authentication required.**
    
    Path Parameters:
    - look_id: UUID of the look to save
    
    Returns the updated look.
    """
    # Find look owned by current user
    look = db.query(DBLook).filter(
        DBLook.id == look_id,
        DBLook.user_id == str(current_user.id)
    ).first()
    
    if not look:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Look not found or you don't have permission to access it"
        )
    
    # Update status
    look.is_in_lookbook = True
    db.commit()
    db.refresh(look)
    
    print(f"✅ Look {look_id} saved to lookbook by user {current_user.email}")
    
    # Return serialized look
    return LookResponse(
        id=str(look.id),
        title=look.title,
        notes=look.notes,
        generated_image_url=look.generated_image_url,
        products=[/* ... serialize products ... */],
        is_in_lookbook=look.is_in_lookbook,
        created_at=look.created_at.isoformat(),
        updated_at=look.updated_at.isoformat()
    )
```

---

### 4. Update List Endpoint

**File: `app/api/v1/endpoints/looks.py`**

Update `list_looks` to support filtering:

```python
@router.get("/", response_model=LookListResponse)
async def list_looks(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    in_lookbook_only: bool = Query(False, description="If true, only return looks saved to lookbook"),  # NEW
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    List looks belonging to the current user.
    
    **Authentication required.**
    
    Query Parameters:
    - skip: Number of records to skip (for pagination)
    - limit: Maximum number of records to return
    - in_lookbook_only: Filter to show only lookbook-saved looks (default: false)
    
    Returns paginated list of looks.
    
    Examples:
    - GET /api/v1/looks/?in_lookbook_only=true  → Only saved looks (lookbook)
    - GET /api/v1/looks/?in_lookbook_only=false → All looks (history)
    """
    # Base query for current user
    query = db.query(DBLook).filter(DBLook.user_id == str(current_user.id))
    
    # Apply lookbook filter if requested
    if in_lookbook_only:
        query = query.filter(DBLook.is_in_lookbook == True)
    
    # Get total count
    total = query.count()
    
    # Get paginated results
    looks = query.order_by(DBLook.created_at.desc()).offset(skip).limit(limit).all()
    
    return LookListResponse(
        looks=looks,
        total=total,
        skip=skip,
        limit=limit
    )
```

---

### 5. Database Migration

**Option A: Create migration endpoint (similar to subscription tables)**

**File: `app/api/v1/endpoints/migrate.py`**

Add new migration function:

```python
@router.post("/add-is-in-lookbook-field")
async def add_is_in_lookbook_field(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    **ADMIN ONLY**: Add is_in_lookbook field to looks table.
    
    This migration:
    1. Adds is_in_lookbook column (boolean, default false)
    2. Sets all existing looks to is_in_lookbook=true (backward compatibility)
    
    Safe to run multiple times.
    """
    # Only admins can run migrations
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can run migrations"
        )
    
    result = {"status": "checking", "steps": []}
    
    try:
        # Check if column already exists
        inspector = inspect(engine)
        columns = [col['name'] for col in inspector.get_columns('looks')]
        
        if 'is_in_lookbook' in columns:
            result["status"] = "already_exists"
            result["message"] = "✅ is_in_lookbook field already exists"
            return result
        
        # Add column with default value
        db.execute(text("""
            ALTER TABLE looks 
            ADD COLUMN is_in_lookbook BOOLEAN NOT NULL DEFAULT FALSE
        """))
        result["steps"].append("✅ Added is_in_lookbook column")
        
        # Set all existing looks to is_in_lookbook=true (backward compatibility)
        # This ensures existing looks appear in lookbook as they did before
        db.execute(text("""
            UPDATE looks 
            SET is_in_lookbook = TRUE 
            WHERE is_in_lookbook = FALSE
        """))
        result["steps"].append("✅ Set all existing looks to is_in_lookbook=true")
        
        # Add index for better query performance
        db.execute(text("""
            CREATE INDEX IF NOT EXISTS idx_looks_is_in_lookbook 
            ON looks(is_in_lookbook)
        """))
        result["steps"].append("✅ Created index on is_in_lookbook")
        
        db.commit()
        
        result["status"] = "success"
        result["message"] = "✅ Migration completed successfully"
        
        return result
        
    except Exception as e:
        db.rollback()
        result["status"] = "error"
        result["error"] = str(e)
        result["message"] = f"❌ Migration failed: {str(e)}"
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=result
        )
```

**Option B: SQL Migration Script (for direct database access)**

```sql
-- Migration: Add is_in_lookbook field to looks table
-- Date: 2025-10-27

BEGIN;

-- Add column
ALTER TABLE looks 
ADD COLUMN IF NOT EXISTS is_in_lookbook BOOLEAN NOT NULL DEFAULT FALSE;

-- Set all existing looks to true (backward compatibility)
UPDATE looks 
SET is_in_lookbook = TRUE 
WHERE is_in_lookbook = FALSE;

-- Add index for performance
CREATE INDEX IF NOT EXISTS idx_looks_is_in_lookbook 
ON looks(is_in_lookbook);

COMMIT;
```

---

## 🎨 Frontend Changes

### Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│ STEP 1: User Generates Look with AI (Look Creator)         │
│  - User selects products, scene, etc.                       │
│  - Click "Generate Look"                                    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ STEP 2: Consume Tokens IMMEDIATELY                         │
│  POST /api/v1/subscription/consume                         │
│  { "operation": "multi_modal" }                             │
│                                                              │
│  Response: { "success": true, "cost": 20 }                  │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ STEP 3: Create Look in Database (Draft State)              │
│  POST /api/v1/looks/                                        │
│  {                                                           │
│    "title": null,  // No title yet                          │
│    "notes": null,  // No notes yet                          │
│    "generatedImageBase64": "...",                           │
│    "products": [...]                                        │
│  }                                                           │
│                                                              │
│  Response: Look with is_in_lookbook=false                   │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ STEP 4: Show Preview to User                               │
│  - Display generated look                                   │
│  - Show "Save to Lookbook" button                          │
│  - Allow editing title/notes                               │
│  - Or "Discard" / "Try Again"                              │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ STEP 5 (Optional): User Saves to Lookbook                  │
│  - User clicks "Save to Lookbook"                          │
│  - PATCH /api/v1/looks/{id} (update title/notes if changed)│
│  - PATCH /api/v1/looks/{id}/save-to-lookbook              │
│                                                              │
│  Response: Look with is_in_lookbook=true                    │
└─────────────────────────────────────────────────────────────┘
```

---

### JavaScript Implementation

**File: Frontend Look Creator**

```javascript
// ========================================
// STEP 1 & 2: Generate Look & Consume Tokens
// ========================================
async function generateLookWithAI(products, scene, layering) {
  try {
    // Show loading state
    setGenerating(true);
    
    // STEP 1: Consume tokens FIRST
    const tokenResponse = await fetch(`${API_BASE}/api/v1/subscription/consume`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${userToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        operation: 'multi_modal',
        description: `Look creation with ${products.length} products`
      })
    });
    
    const tokenResult = await tokenResponse.json();
    
    if (!tokenResult.success) {
      // Insufficient tokens - show upgrade modal
      showUpgradeModal({
        operation: 'Look Creation',
        cost: tokenResult.cost,
        available: tokenResult.availableTokens,
        shortfall: tokenResult.cost - tokenResult.availableTokens
      });
      return null;
    }
    
    // Update token balance in UI
    updateUserTokenBalance(tokenResult.availableTokens);
    
    // STEP 2: Call AI service to generate the image
    const generatedImageBase64 = await callAIGenerationService(products, scene, layering);
    
    // STEP 3: Create look in database (draft state)
    const lookResponse = await createLook({
      title: null,  // No title yet - user will add later
      notes: null,  // No notes yet
      generatedImageBase64: generatedImageBase64,
      products: products.map(p => ({
        sku: p.sku,
        name: p.name,
        designer: p.designer,
        price: p.price,
        productUrl: p.url,
        thumbnailBase64: p.thumbnailBase64
      }))
    });
    
    // STEP 4: Show preview modal
    showLookPreviewModal(lookResponse);
    
    return lookResponse;
    
  } catch (error) {
    console.error('Failed to generate look:', error);
    showErrorNotification('Failed to generate look. Please try again.');
    return null;
  } finally {
    setGenerating(false);
  }
}


// ========================================
// STEP 3: Create Look (Draft)
// ========================================
async function createLook(lookData) {
  const response = await fetch(`${API_BASE}/api/v1/looks/`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${userToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(lookData)
  });
  
  if (!response.ok) {
    throw new Error('Failed to create look');
  }
  
  return await response.json();
}


// ========================================
// STEP 4: Show Preview Modal
// ========================================
function showLookPreviewModal(look) {
  // Display modal with:
  // - Generated look image
  // - Product list
  // - Title input field (optional)
  // - Notes textarea (optional)
  // - "Save to Lookbook" button
  // - "Discard" or "Cancel" button
  
  const modal = createModal({
    title: 'Your Generated Look',
    content: `
      <img src="${look.generatedImageUrl}" alt="Generated Look" />
      <input id="look-title" placeholder="Add a title (optional)" />
      <textarea id="look-notes" placeholder="Add notes (optional)"></textarea>
      <div class="products-list">
        ${look.products.map(p => `<div>${p.name}</div>`).join('')}
      </div>
      <div class="actions">
        <button id="save-to-lookbook" class="btn-primary">
          Save to Lookbook
        </button>
        <button id="discard" class="btn-secondary">
          Discard
        </button>
      </div>
    `,
    onSave: () => saveToLookbook(look.id),
    onDiscard: () => discardLook(look.id)
  });
  
  modal.show();
}


// ========================================
// STEP 5: Save to Lookbook
// ========================================
async function saveToLookbook(lookId) {
  try {
    const title = document.getElementById('look-title').value.trim();
    const notes = document.getElementById('look-notes').value.trim();
    
    // Update title/notes if user entered them
    if (title || notes) {
      await fetch(`${API_BASE}/api/v1/looks/${lookId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${userToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ title, notes })
      });
    }
    
    // Mark as saved to lookbook
    const response = await fetch(`${API_BASE}/api/v1/looks/${lookId}/save-to-lookbook`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${userToken}`
      }
    });
    
    if (!response.ok) {
      throw new Error('Failed to save to lookbook');
    }
    
    showSuccessNotification('✅ Look saved to your lookbook!');
    closeModal();
    
    // Refresh lookbook view if currently open
    if (isLookbookPageActive()) {
      refreshLookbookList();
    }
    
  } catch (error) {
    console.error('Failed to save to lookbook:', error);
    showErrorNotification('Failed to save to lookbook. Please try again.');
  }
}


// ========================================
// Discard Look (Optional)
// ========================================
async function discardLook(lookId) {
  // Optional: Delete the look if user doesn't want to keep it
  // Or just close modal and keep it in history
  
  if (confirm('Discard this look? It will still be in your history.')) {
    closeModal();
  }
  
  // If you want to actually delete it:
  // await fetch(`${API_BASE}/api/v1/looks/${lookId}`, { method: 'DELETE' });
}


// ========================================
// Fetch Lookbook (Saved Looks Only)
// ========================================
async function fetchLookbook() {
  const response = await fetch(
    `${API_BASE}/api/v1/looks/?in_lookbook_only=true`,
    {
      headers: { 'Authorization': `Bearer ${userToken}` }
    }
  );
  
  return await response.json();
}


// ========================================
// Fetch All Looks (History)
// ========================================
async function fetchAllLooks() {
  const response = await fetch(
    `${API_BASE}/api/v1/looks/?in_lookbook_only=false`,
    {
      headers: { 'Authorization': `Bearer ${userToken}` }
    }
  );
  
  return await response.json();
}


// ========================================
// UI: Lookbook Tab vs History Tab
// ========================================
function setupLooksTabs() {
  // Tab 1: Lookbook (Saved looks)
  document.getElementById('lookbook-tab').addEventListener('click', async () => {
    const data = await fetchLookbook();
    displayLooks(data.looks, 'lookbook-container');
  });
  
  // Tab 2: History (All looks)
  document.getElementById('history-tab').addEventListener('click', async () => {
    const data = await fetchAllLooks();
    displayLooks(data.looks, 'history-container');
  });
}
```

---

## 🧪 Testing Checklist

### Backend Testing

- [ ] **Migration runs successfully**
  - [ ] Column `is_in_lookbook` added to looks table
  - [ ] All existing looks set to `is_in_lookbook=true`
  - [ ] Index created successfully

- [ ] **Create Look endpoint**
  - [ ] Creates look with `is_in_lookbook=false` by default
  - [ ] Associates with correct user
  - [ ] Returns correct response with new field

- [ ] **Save to Lookbook endpoint**
  - [ ] Updates `is_in_lookbook` to `true`
  - [ ] Only owner can save their looks
  - [ ] Returns updated look

- [ ] **List endpoint filtering**
  - [ ] `in_lookbook_only=false` returns all looks
  - [ ] `in_lookbook_only=true` returns only saved looks
  - [ ] Pagination works correctly

- [ ] **Swagger UI updated**
  - [ ] New endpoint appears in docs
  - [ ] New query parameter documented
  - [ ] New response field documented

### Frontend Testing

- [ ] **Token consumption**
  - [ ] Tokens consumed before look creation
  - [ ] Insufficient tokens shows upgrade modal
  - [ ] Token balance updates after consumption

- [ ] **Look creation flow**
  - [ ] Look created immediately after generation
  - [ ] Preview modal shows correctly
  - [ ] Title/notes can be edited

- [ ] **Save to lookbook**
  - [ ] Button works correctly
  - [ ] Title/notes saved if entered
  - [ ] Look appears in lookbook after save
  - [ ] Success notification shown

- [ ] **List views**
  - [ ] Lookbook tab shows only saved looks
  - [ ] History tab shows all looks
  - [ ] Both tabs paginate correctly

---

## 📝 API Documentation Update

Add to `LOOKS_API_DOCUMENTATION.md`:

### New Endpoint: Save to Lookbook

**`PATCH /api/v1/looks/{look_id}/save-to-lookbook`**

Mark a look as saved to lookbook.

#### Request
```
PATCH /api/v1/looks/abc-123-def/save-to-lookbook
Authorization: Bearer <JWT_TOKEN>
```

#### Response (200 OK)
```json
{
  "id": "abc-123-def",
  "title": "Summer Casual",
  "notes": "Perfect for beach day",
  "generatedImageUrl": "https://...",
  "is_in_lookbook": true,
  "products": [...],
  "createdAt": "2025-10-27T10:00:00Z",
  "updatedAt": "2025-10-27T10:05:00Z"
}
```

### Updated Endpoint: List Looks

**`GET /api/v1/looks/?in_lookbook_only={true|false}`**

New query parameter:
- `in_lookbook_only` (boolean, default: false)
  - `true`: Only return looks saved to lookbook
  - `false`: Return all looks (history)

---

## 🚀 Deployment Steps

### Local Development

1. **Update code** (models, schemas, endpoints)
2. **Restart server**
3. **Test manually** with Swagger UI
4. **Run frontend** and test flow

### Production Deployment

1. **Deploy backend code** (git push)
2. **Wait for Render deployment** (~2-3 minutes)
3. **Run migration**:
   - Option A: Use HTML migration tool
   - Option B: Call migration endpoint via Swagger
   - Option C: Run SQL script directly
4. **Verify** migration success
5. **Test** on production with real data
6. **Deploy frontend** changes

---

## 🎯 Benefits

✅ **Token consumption on generation** (not on save)
✅ **Full history tracking** (all generated looks)
✅ **Explicit save action** (user controls lookbook)
✅ **Minimal changes** to existing code
✅ **Backward compatible** (existing looks remain in lookbook)
✅ **Better user experience** (preview before save)

---

## 📚 Related Files

- `app/models/look.py` - Look model
- `app/schemas/look.py` - Look schemas
- `app/api/v1/endpoints/looks.py` - Look endpoints
- `app/api/v1/endpoints/migrate.py` - Migration endpoint
- `FRONTEND_TOKEN_CONSUMPTION_GUIDE.md` - Token consumption guide

---

## ⚠️ Important Notes

1. **Existing Looks**: Migration sets `is_in_lookbook=true` for all existing looks to maintain backward compatibility

2. **Token Consumption**: Always consume tokens BEFORE creating the look (see FRONTEND_TOKEN_CONSUMPTION_GUIDE.md)

3. **User Experience**: Consider adding:
   - Auto-save drafts (optional)
   - Ability to regenerate from history
   - Bulk actions (save multiple to lookbook)

4. **Performance**: The `is_in_lookbook` field is indexed for fast filtering

5. **Future Enhancement**: Could add "favoriting" or "starring" looks for additional organization

---

**Implementation Status**: 📝 Ready for implementation
**Estimated Effort**: 4-6 hours (backend + frontend + testing)
**Priority**: Medium
**Complexity**: Low-Medium

